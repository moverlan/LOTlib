# -*- coding: utf-8 -*-

from LOTlib.Miscellaneous import cached

"""
Interface for a node in a tree generated by expanding rules in a grammar
"""

class Node(object):
    def __init__(self, parent, rule_state=None):
        self._parent = parent
        if parent is None:
            self._rule_state = rule_state
        else:
            self._rule_state = parent._rule_state

    def __str__(self):
        raise NotImplementedError()

    @property
    def pystring(self):
        raise NotImplementedError()

    def debugstring(self, depth=0):
        raise NotImplementedError()

    def __call__(self):
        raise NotImplementedError()

    @property
    def log_prob(self):
        raise NotImplementedError()

    @property
    def size(self):
        raise NotImplementedError()

    def __iter__(self):
        raise NotImplementedError()

    @property
    def is_terminal(self):
        return self.size == 1

    @property
    def is_nonterminal(self):
        return self.size > 1

    @property
    def parent(self):
        return self._parent

    @property
    @cached
    def root(self):
        current = self
        while not current.is_root:
            current = current.parent
        return current

    @property
    def is_root(self):
        return self.parent is None



#class BVState(object):
    #def __init__(self, cache):
        #self.cache = cache
        #self.state = defaultdict(list)

    #def update(self, rule):
        #"""
        #Takes a lambda rule and updates the current state by adding a new bv rule to it
        #"""
        ## copy the state because we're mutating it
        #self.state = copy(self.state) # each lhs points to original list
        #state = self.state[rule.bv_type] = copy(self.state[rule.bv_type]) # this rule's key now points to new list
        #new_rule = self.cache.get_rule(bv_type, len(state)+1)
        #state.append(new_rule)
        #return new_rule.varname
