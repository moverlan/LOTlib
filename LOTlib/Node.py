# -*- coding: utf-8 -*-

from LOTlib.Miscellaneous import cached
from contextlib import contextmanager

"""
Interface for a node in a tree generated by expanding rules in a grammar
"""

class Node(object):
    def __init__(self, parent, state=None):
        self._parent = parent
        if state is None:
            assert parent is not None
            self._state = parent.state
        else:
            self._state = state

    def __str__(self):
        raise NotImplementedError()

    @property
    def pystring(self):
        raise NotImplementedError()

    def debugstring(self, depth=0):
        raise NotImplementedError()

    #def __call__(self):
        #raise NotImplementedError()

    @property
    def log_prob(self):
        raise NotImplementedError()

    @property
    def size(self):
        raise NotImplementedError()

    def __iter__(self):
        raise NotImplementedError()

    @property
    def is_terminal(self):
        return self.size == 1

    @property
    def is_nonterminal(self):
        return self.size > 1

    @property
    def parent(self):
        return self._parent

    @property
    @cached
    def root(self):
        current = self
        while not current.is_root:
            current = current.parent
        return current

    @property
    def is_root(self):
        return self.parent is None

    @property
    def rule_state(self):
        return self._state.rules


class RuleState(object):
    """
    State objects hold information about the state of the rules as
    function nodes are expanded
    This class uses copy-on-write semantics to minimize memory usage
    """

    def __init__(self, rules={}):
        self._rules = rules

    @property
    def rules(self):
        return self._rules

    def update_rules(self, rule):
        """
        Makes a new bv rule from the supplied lambda rule, updates the state with it
        """
        assert rule.is_lambda
        # shallow copy dict
        self._rules = copy(self._rules)
        # self._rule_state now points to new dict, but each key points to original list, 
        # shallow copy the bv rule list -- 
        state = self.rules[rule.bv_type] = copy(self.rules[rule.bv_type])
        # the bv rule's key now points to new list, but list elements point to original rules
        varname = rule.bv_prefix + str(len(state)+1)       # unique name for this var
        new_rule = rule.make_bv_rule(1.0, varname)   # make the rule
        state.append(new_rule)
        





    #def update(self, rule):
        #"""
        #Takes a lambda rule and updates the current state by adding a new bv rule to it
        #"""
        ## copy the state because we're mutating it
        #self.state = copy(self.state) # each lhs points to original list
        #state = self.state[rule.bv_type] = copy(self.state[rule.bv_type]) # this rule's key now points to new list
        #new_rule = self.cache.get_rule(bv_type, len(state)+1)
        #state.append(new_rule)
        #return new_rule.varname
