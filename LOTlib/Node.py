# -*- coding: utf-8 -*-

#from LOTlib.Miscellaneous import cached
from contextlib import contextmanager
from copy import copy
from LOTlib.Miscellaneous import Cache

"""
Interface for a node in a tree generated by expanding rules in a grammar
"""

class Node(object):
    def __init__(self, grammar=None):
        if grammar is not None:
            self._grammar = grammar
        self._parent = None

        self._cache = Cache

    @property
    def grammar(self):
        if self.is_root:
            assert hasattr(self, '_grammar'), 'no grammar in {0}'.format(type(self))
            assert self._grammar is not None
            return self._grammar
        else:
            assert not hasattr(self, '_grammar')
            return self.parent.grammar

    def __str__(self):
        raise NotImplementedError()

    @property
    def pystring(self):
        raise NotImplementedError()

    def debugstring(self, depth=0):
        raise NotImplementedError()

    @property
    def return_type(self):
        raise NotImplementedError()

    @property
    def name(self):
        raise NotImplementedError()

    def evaluate(self, state={}):
        raise NotImplementedError()

    @property
    def log_prob(self):
        raise NotImplementedError()

    @property
    def size(self):
        """
        Returns the size of the tree for which this node is the root
        """
        return len(list(self))

    def __iter__(self):
        raise NotImplementedError()

    @property
    def is_terminal(self):
        return len(self.children) == 0

    @property
    def is_nonterminal(self):
        return len(self.children) >= 1

    @property
    def parent(self):
        return self._parent

    @property
    def root(self):
        current = self
        while not current.is_root:
            current = current.parent
        return current

    @property
    def is_root(self):
        return self.parent is None

    #def copy_tree(self):
        #"""
        #returns a copy of a full tree as shallowly as possible -- only child
        #parent links are remade
        #"""
        #assert self.is_root, 'can only copy full trees'
        #return self._copy()

    #def _copy(self, down_to=None):
        #new = copy(self)
        #if new.is_nonterminal:
            #new._children = copy(new._children)
            #for i, child in enumerate(self.children):
                #if down_to and child is down_to:
                    #self._clear_cache()
                    #continue
                #new._children[i] = child._copy()
                #new._children[i]._parent = new
                #assert child is not new.child(i)
        #assert self is not new
        #return new

    #def copy(self):
        #return self.copy_down_to(None)

    def copy(self, removing=None, replaced_with=None):
        """
        returns a copy of the tree rooted by this node, possibly excluding
        the specified node, and possibly replacing it
        """
        if replaced_with is not None:
            assert removing is not None
        if removing is not None and not hasattr(removing, '__len__'):
            removing = [removing]
        if removing is not None and self in removing:
            if replaced_with is not None:
                #print 'returning replaced with'
                if self.is_root:
                    replaced_with._grammar = self._grammar
                return replaced_with
            else:
                #print 'returning none'
                return None
        new = self.duplicate()
        for i, child in enumerate(self.children):
            if child is not None:
                new_child = child.copy(removing, replaced_with)
                if new_child is not None:
                    new.set_child(i, new_child)
        return new

    def fill_out(self, chooser):
        for i, child in enumerate(self.children):
            if child is None:
                self.generate_child(i, chooser)
            else:
                child.fill_out(chooser)

    def is_descendant_of(self,node):
        current = self
        while True:
            current = current.parent
            if current is None:
                break
            if node is current:
                return True
        return False


    #def through(self, stop):
        #for node in self:
            #if node is stop:
                #return
            #else:
                #yield node

            #if child is not removing:
                #self.set_child(i, child.copy(replacing, replaced_with))
            #elif replaced_with is not None:
                #self.set_child(i, replaced_with)

    #def _clear_cache(dependency):
        #assert dependency in ['parent','child'], "{0} not 'parent' or 'child'".format(dependency)
        #if dependency == 'parent':
            #self._cache.clear('parent')
            #for child in self.children:
                #child._clear_cache('parent')
        #else:
            #self._cache.clear('child')
            #self.parent.clear_cache('child')


    @property
    def child_n(self):
        """
        the index of this node in its parents children
        """
        assert hasattr(self, '_child_n'), 'child_n not yet set'
        return self._child_n

    def _set_parent(self, parent, child_n):
        assert parent.child(child_n) is self, 'child/parent mismatch'
        if self.parent is not None:
            #self._clear_cache('parent')
            del self._grammar
        self._child_n = child_n
        self._parent = parent

    def generate_children(self, chooser):
        """
        recursively instantiates the children of this node
        """
        for i in range(len(self.children)):
            self.generate_child(i, chooser)

    def duplicate(self):
        raise NotImplementedError

    #def set_grammar(self, grammar):
        #"""
        #For a root node, sets its rule state to the given rules. Can only
        #be called once and must be called before instantiating any children
        #"""
        #assert self.is_root
        #assert self.grammar is None
        #assert all([child is None for child in self.children])
        #self._grammar = grammar



    #@classmethod
    #def make_root(Clas, gen_prob, return_type, state, *args, **kwargs):
        #"""
        #Makes a node of the specified type with no parent and sets its
        #state to the given rules
        #"""
        #print Clas
        #print args
        #print kwargs
        #node = Clas(None, gen_prob, return_type, *args, **kwargs)
        #node._state = RuleState(rules)
        #return node

    #@property
    #def rule_state(self):
        #return self._rule_state.rules

    #@staticmethod
    #def new(rule, grammar):
        #"""
        #returns a new root node using the given rule choosing function
        #"""
        #return node


            #else:
                #raise Exception('Type {0} should be a non-terminal, terminal, or bound var'.format(typ))


#"""
#class to track the state of bound vars during the execution of a
#function tree
#"""
#class ExecutionState(object):
    #"""
    #Keeps track of the values assigned to bound vars
    #"""
    #def __init__(self):
        #self._value = {}
        #self._stored_value = None

    #def store(self, value):
        #"""
        #Stores the computed value of the argument to an apply statement
        #"""
        #self._stored_value = value

    #@contextmanager
    #def bind_stored_to(varname):
        #"""
        #binds the stored value (from previous apply) to the given variable
        #and unbinds it on exit
        #"""
        #assert self._stored_value is not None
        #self._value[varname] = self._stored_value
        #self._stored_value = None
        #yield
        #del self._value[varname]

    #def value(self, varname):
        #return self._value[varname]

    #@property
    #def bvs(self):
        #return self._value.keys()



#class RuleState(object):
    #"""
    #State objects hold information about the state of the rules as
    #function nodes are expanded
    #This class uses copy-on-write semantics to minimize memory usage
    #"""

    #def __init__(self, rules={}):
        #self._rules = rules
        #self._bvs = set()

    #@property
    #def rules(self):
        #return self._rules

    #def update_rules(self, node):
        #"""
        #Makes a new bv rule from the supplied lambda rule, updates the state with it
        #"""
        #assert node.name == 'lambda_'
        ## copy just the minimum necessary to update state
        #self._rules = copy(self._rules)
        #state = self.rules[rule.bv_type] = copy(self.rules[rule.bv_type])
        #varname = node.bv_prefix + str(len(state)+1)       # unique name for this var
        #new_rule = node.make_bv_rule(1.0, varname)   # make the rule
        #state.append(new_rule)
        #self.bvs.add(varname)
        #return varname

    #def update(self, rule):
        #"""
        #Takes a lambda rule and updates the current state by adding a new bv rule to it
        #"""
        ## copy the state because we're mutating it
        #self.state = copy(self.state) # each lhs points to original list
        #state = self.state[rule.bv_type] = copy(self.state[rule.bv_type]) # this rule's key now points to new list
        #new_rule = self.cache.get_rule(bv_type, len(state)+1)
        #state.append(new_rule)
        #return new_rule.varname
