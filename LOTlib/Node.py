# -*- coding: utf-8 -*-

#from LOTlib.Miscellaneous import cached
from contextlib import contextmanager
from copy import copy

"""
Interface for a node in a tree generated by expanding rules in a grammar
"""

class Node(object):
    def __init__(self, grammar=None):
        if grammar is not None:
            self._grammar = grammar

    @property
    def grammar(self):
        if self.is_root:
            assert hasattr(self, '_grammar')
            assert self._grammar is not None
            return self._grammar
        else:
            assert not hasattr(self, '_grammar')
            return parent.grammar

    def __str__(self):
        raise NotImplementedError()

    @property
    def pystring(self):
        raise NotImplementedError()

    def debugstring(self, depth=0):
        raise NotImplementedError()

    @property
    def return_type(self):
        raise NotImplementedError()

    def evaluate(self, state={}):
        raise NotImplementedError()

    @property
    def log_prob(self):
        raise NotImplementedError()

    @property
    def size(self):
        """
        Returns the size of the tree for which this node is the root
        """
        return len(list(self))

    def __iter__(self):
        raise NotImplementedError()

    @property
    def is_terminal(self):
        return len(self.children) == 0

    @property
    def is_nonterminal(self):
        return len(self.children) >= 1

    @property
    def parent(self):
        if not hasattr(self, '_parent'):
            return None
        return self._parent

    @property
    def root(self):
        current = self
        while not current.is_root:
            current = current.parent
        return current

    @property
    def is_root(self):
        return self.parent is None

    def copy_tree(self):
        """
        returns a copy of a full tree as shallowly as possible -- only child
        parent links are remade
        """
        assert self.is_root, 'can only copy full trees'
        return self._copy()

    def _copy(self):
        new = copy(self)
        if new.is_nonterminal:
            new._children = copy(new._children)
            for i, child in enumerate(self.children):
                new._children[i] = child._copy()
                new._children[i]._parent = new
                assert child is not new.child(i)
        assert self is not new
        return new

    @property
    def child_n(self):
        """
        the index of this node in its parents children
        """
        assert self.hasattr('_child_n'), 'child_n not yet set'
        return self._child_n

    def _set_parent(self, parent, child_n):
        assert self.parent is None
        self._child_n = child_n
        assert parent.child(self.child_n) is self, 'child/parent mismatch'
        self._parent = parent

    #def set_grammar(self, grammar):
        #"""
        #For a root node, sets its rule state to the given rules. Can only
        #be called once and must be called before instantiating any children
        #"""
        #assert self.is_root
        #assert self.grammar is None
        #assert all([child is None for child in self.children])
        #self._grammar = grammar



    #@classmethod
    #def make_root(Clas, gen_prob, return_type, state, *args, **kwargs):
        #"""
        #Makes a node of the specified type with no parent and sets its
        #state to the given rules
        #"""
        #print Clas
        #print args
        #print kwargs
        #node = Clas(None, gen_prob, return_type, *args, **kwargs)
        #node._state = RuleState(rules)
        #return node

    #@property
    #def rule_state(self):
        #return self._rule_state.rules

    #@staticmethod
    #def new(rule, grammar):
        #"""
        #returns a new root node using the given rule choosing function
        #"""
        #return node


            #else:
                #raise Exception('Type {0} should be a non-terminal, terminal, or bound var'.format(typ))


#"""
#class to track the state of bound vars during the execution of a
#function tree
#"""
#class ExecutionState(object):
    #"""
    #Keeps track of the values assigned to bound vars
    #"""
    #def __init__(self):
        #self._value = {}
        #self._stored_value = None

    #def store(self, value):
        #"""
        #Stores the computed value of the argument to an apply statement
        #"""
        #self._stored_value = value

    #@contextmanager
    #def bind_stored_to(varname):
        #"""
        #binds the stored value (from previous apply) to the given variable
        #and unbinds it on exit
        #"""
        #assert self._stored_value is not None
        #self._value[varname] = self._stored_value
        #self._stored_value = None
        #yield
        #del self._value[varname]

    #def value(self, varname):
        #return self._value[varname]

    #@property
    #def bvs(self):
        #return self._value.keys()



#class RuleState(object):
    #"""
    #State objects hold information about the state of the rules as
    #function nodes are expanded
    #This class uses copy-on-write semantics to minimize memory usage
    #"""

    #def __init__(self, rules={}):
        #self._rules = rules
        #self._bvs = set()

    #@property
    #def rules(self):
        #return self._rules

    #def update_rules(self, node):
        #"""
        #Makes a new bv rule from the supplied lambda rule, updates the state with it
        #"""
        #assert node.name == 'lambda_'
        ## copy just the minimum necessary to update state
        #self._rules = copy(self._rules)
        #state = self.rules[rule.bv_type] = copy(self.rules[rule.bv_type])
        #varname = node.bv_prefix + str(len(state)+1)       # unique name for this var
        #new_rule = node.make_bv_rule(1.0, varname)   # make the rule
        #state.append(new_rule)
        #self.bvs.add(varname)
        #return varname





    #def update(self, rule):
        #"""
        #Takes a lambda rule and updates the current state by adding a new bv rule to it
        #"""
        ## copy the state because we're mutating it
        #self.state = copy(self.state) # each lhs points to original list
        #state = self.state[rule.bv_type] = copy(self.state[rule.bv_type]) # this rule's key now points to new list
        #new_rule = self.cache.get_rule(bv_type, len(state)+1)
        #state.append(new_rule)
        #return new_rule.varname
