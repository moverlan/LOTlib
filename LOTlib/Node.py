# -*- coding: utf-8 -*-

from LOTlib.Miscellaneous import cached
from contextlib import contextmanager

"""
Interface for a node in a tree generated by expanding rules in a grammar
"""

class Node(object):
    def __init__(self, parent, state=None):
        self._parent = parent
        if state is None:
            assert parent is not None
            self.state = parent.state

    def __str__(self):
        raise NotImplementedError()

    @property
    def pystring(self):
        raise NotImplementedError()

    def debugstring(self, depth=0):
        raise NotImplementedError()

    #def __call__(self):
        #raise NotImplementedError()

    @property
    def log_prob(self):
        raise NotImplementedError()

    @property
    def size(self):
        raise NotImplementedError()

    def __iter__(self):
        raise NotImplementedError()

    @property
    def is_terminal(self):
        return self.size == 1

    @property
    def is_nonterminal(self):
        return self.size > 1

    @property
    def parent(self):
        return self._parent

    @property
    @cached
    def root(self):
        current = self
        while not current.is_root:
            current = current.parent
        return current

    @property
    def is_root(self):
        return self.parent is None


class State(object):
    """
    State objects hold information about the state of nodes in a function tree
    It includes the set of all rules that are available, and the values
    that have been assigned to bound variables
    This class uses copy-on-write semantics to minimize memory usage
    """

    def __init__(self, rules={}, value={}):
        self._rules = rules
        self._value = value
        self._stored_value = None

    def store(self, value):
        """
        Stores the computed value of the argument to an apply statement
        """
        self._stored_value = value
  
    def update_rules(self, rule):
        """
        Makes a new bv rule from the supplied lambda rule, updates the state with it
        """
        assert rule.is_lambda
        # shallow copy dict
        self._rules = copy(self._rules)
        # self._rule_state now points to new dict, but each key points to original list, 
        # shallow copy the bv rule list -- 
        state = self.rule_state[rule.bv_type] = copy(self.rule_state[rule.bv_type])
        # the bv rule's key now points to new list, but list elements point to original rules
        varname = rule.bv_prefix + str(len(state)+1)       # unique name for this var
        new_rule = rule.make_bv_rule(1.0, varname)   # make the rule
        state.append(new_rule)
        

    @contextmanager
    def bind_stored_to(varname):
        """
        binds the stored value (from previous apply) to the given variable
        and unbinds it on exit
        """
        self._value[varname] = self._stored_value
        self._stored_value = None
        yield
        del self._value[varname]

    def value(self, varname):
        return self._value(varname)

    def has_stored_value(self):
        return self._stored_value is not None





    #def update(self, rule):
        #"""
        #Takes a lambda rule and updates the current state by adding a new bv rule to it
        #"""
        ## copy the state because we're mutating it
        #self.state = copy(self.state) # each lhs points to original list
        #state = self.state[rule.bv_type] = copy(self.state[rule.bv_type]) # this rule's key now points to new list
        #new_rule = self.cache.get_rule(bv_type, len(state)+1)
        #state.append(new_rule)
        #return new_rule.varname
